<h1 id="db를-설계할때이미-정해져-있는-데이터라면-pk를-직접-정해서-넣어줘야-하는가">DB를 설계할때..이미 정해져 있는 데이터라면 PK를 직접 정해서 넣어줘야 하는가?</h1>
<p>결론부터 말씀드리면, &quot;이미 정해져 있는 데이터(코드성 데이터, 마스터 데이터)&quot;라면 PK를 직접 정해서 넣어주는 것(Natural Key 또는 지정된 ID)이 훨씬 유지보수에 유리합니다.
아마 이번에 데이터 업데이트를 하시면서 겪으신 문제점은 &quot;환경(PROD vs STAG) 간의 PK 불일치&quot; 문제였을 가능성이 큽니다.
왜 그런지, 그리고 어떤 기준을 잡아야 하는지 명확하게 정리해 드릴게요.</p>
<ol>
<li>왜 &quot;정해진 데이터&quot;는 PK를 직접 지정해야 할까?
이미 정해져 있는 데이터(예: 은행 코드, 배송 상태 코드, 카테고리 등)를 Auto Increment (Serial, Identity)로 관리하면 다음과 같은 치명적인 문제가 발생합니다.
❌ 문제 상황: Auto Increment의 배신<ul>
<li>PROD DB 상황:</li>
<li>1: 주문완료, 2: 배송중, 3: 배송완료 순서로 데이터가 생성됨.</li>
<li>STAG DB 상황:</li>
<li>개발하다가 데이터를 지우고 다시 넣었는데 순서가 꼬임.</li>
<li>1: 배송중, 2: 주문완료 ...</li>
<li>결과:</li>
<li>애플리케이션 코드에서 if (status_id == 1) 이라고 짠 로직이 PROD에서는 '주문완료'인데, STAG에서는 '배송중'으로 동작함.</li>
<li>데이터 동기화 시, PROD의 1번 데이터를 STAG로 가져오면 엉뚱한 데이터와 매핑되거나 충돌남.
✅ 해결: PK 직접 지정 (Manual/Natural Key)</li>
<li>PROD/STAG 모두:</li>
<li>100: 주문완료, 200: 배송중, 300: 배송완료 라고 PK를 우리가 정해서 INSERT 함.</li>
<li>장점:</li>
<li>어떤 DB 환경이든 ID 200은 무조건 배송중이라는 것을 보장할 수 있음.</li>
<li>데이터 동기화(덮어쓰기)를 할 때도 ID 충돌 걱정 없이 UPSERT (있으면 업데이트, 없으면 삽입) 하기가 매우 편함.</li>
</ul>
</li>
<li>기준: 언제 직접 정하고, 언제 자동 증가를 쓸까?
DB 설계 시 데이터의 성격에 따라 PK 전략을 나누는 것이 정석입니다.<table>
<thead>
<tr>
<th>구분</th>
<th>데이터 예시</th>
<th>PK 전략 추천</th>
<th>이유</th>
</tr>
</thead>
<tbody><tr>
<td>코드성/마스터 데이터</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>(정해진 데이터)</td>
<td>공통 코드, 카테고리, 은행 목록, 지역 코드, 관리자 권한 목록</td>
<td>직접 지정 (Manual)</td>
<td></td>
</tr>
<tr>
<td>또는 Natural Key</td>
<td>환경 간 일치성 중요.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>개발, 테스트, 운영 DB 모두 ID가 같아야 함.</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>트랜잭션 데이터</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>(계속 쌓이는 데이터)</td>
<td>사용자(User), 주문(Order), 로그(Log), 게시글</td>
<td>자동 증가 (Auto Increment)</td>
<td></td>
</tr>
<tr>
<td>또는 UUID</td>
<td>데이터 양이 많고 무한히 늘어남.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>순서나 의미보다는 고유성이 중요.</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>매핑 테이블</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>(N:M 관계 해소)</td>
<td>사용자-권한 매핑, 상품-태그 매핑</td>
<td>복합키 (Composite Key)</td>
<td></td>
</tr>
<tr>
<td>또는 자동 증가</td>
<td>(A_ID, B_ID) 조합 자체가 PK가 되는 경우가 많음.</td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li>&quot;데이터 업데이트&quot; 시 겪으셨을 문제점
아마 <strong>&quot;데이터 동기화&quot;</strong>를 하면서 다음과 같은 상황 때문에 고민하셨을 겁니다.<ul>
<li>시퀀스(Sequence) 꼬임:</li>
<li>데이터를 덮어씌웠는데, 시퀀스 값(nextval)은 초기화가 안 되어 있어서, 새 데이터를 넣으려고 하니 Duplicate Key Error가 발생.</li>
<li>-&gt; 직접 지정 PK를 쓰면 시퀀스 신경 쓸 필요가 없습니다.</li>
<li>FK(외래키) 참조 깨짐:</li>
<li>주문 테이블이 상태_ID=5를 참조하고 있는데, STAG DB를 다시 만들면서 상태_ID가 6으로 바뀌어버림. -&gt; 주문 데이터가 고아가 됨.</li>
<li>-&gt; 직접 지정 PK를 쓰면 참조 무결성이 깨질 일이 줄어듭니다.</li>
</ul>
</li>
<li>결론 및 제안
설계하고 계신 테이블이 <strong>&quot;변하지 않거나, 관리자가 통제 가능한 범위의 데이터(카테고리, 설정 값 등)&quot;</strong>라면, PK를 직접 정해서 넣으시는 것이 맞습니다.
어떻게 바꾸면 좋을까요?<ul>
<li>의미 있는 숫자/문자 사용:</li>
<li>단순 1, 2, 3 대신, 확장성을 고려해 1001, 1002 처럼 간격을 두거나,</li>
<li>아예 KR, US, JP 처럼 문자열 코드(String PK)를 사용하는 것도 좋습니다. (데이터가 많지 않다면 성능 차이 미미함)</li>
<li>PostgreSQL에서의 팁:</li>
<li>PK를 직접 넣을 때는 generated always as identity 보다는 일반적인 컬럼으로 두고 NOT NULL 제약만 거는 것이 관리하기 편합니다.
한 줄 요약:</li>
</ul>
</li>
</ol>
<p><strong>&quot;개발 서버와 운영 서버에서 ID값이 똑같아야 마음이 편한 데이터&quot;</strong>라면, 무조건 PK를 직접 지정하세요.</p>